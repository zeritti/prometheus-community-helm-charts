replicaCount: 1

image:
  registry: quay.io
  repository: prometheuscommunity/postgres-exporter
  # if not set appVersion field from Chart.yaml is used
  tag: ""
  pullPolicy: IfNotPresent

  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistrKeySecretName

command: []

service:
  type: ClusterIP
  port: 80
  targetPort: 9187
  name: http
  labels: {}
  annotations: {}

automountServiceAccountToken: false

serviceMonitor:
  # Use a ServiceMonitor to configure scraping
  # To use a multi target configuration, set both enabled
  # and multiTarget.enabled to true
  enabled: false
  # Set the namespace the ServiceMonitor should be deployed
  namespace: ""
  # Set how frequently Prometheus should scrape
  interval: 30s
  # Set path to metrics endpoint. If multiTarget is enabled, path gets set to /probe.
  telemetryPath: /metrics
  # Set labels for the ServiceMonitor, use this to define your scrape label for Prometheus Operator
  labels: {}
  # Set timeout for scrape
  timeout: 10s
  # Set of labels to transfer from the Kubernetes Service onto the target
  targetLabels: []
  # MetricRelabelConfigs to apply to samples before ingestion
  metricRelabelings: []
  # Set relabel_configs as per https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  relabelings: []

  ## Enable multi-target functionality in the exporter.
  ## https://github.com/prometheus-community/postgres_exporter#multi-target-support-beta
  ## A configuration file should be available when using auth_module, see config.postgresExporter below.
  ## A service monitor will be created for each target if enabled.
  ## Fields below are additions to those above.
  multiTarget:
    enabled: false

    ## Additional common fields for all targets
    ## Authorization credentials via a secret (previously BearerTokenFile)
    authorization:
      ## secret with credentials (bearer token)
      credentials: {}
        # key: token
        # name: credentials
    ## jobLabel specifies a service' label's value to be used for job
    ## e.g. "app"
    jobLabel: ""
    ## Protocol scheme
    scheme: http
    ## tlsConfig if the exporter requires TLS communication with Prometheus
    tlsConfig: {}
    ## These two common fields can be overriden in each target
    ## Default authModule as set in the configuration file
    authModule: ""
    ## Default port number
    port: "5432"

    targets: []
    # - name: pg01
      ## port of the Postgres instance
      # port: ""
      ## hostname that the exporter will connect to
      # endpoint: postgresql.postgresql
      ## additional labels for this target
      # labels: {}
      ## scrape interval
      # interval: 60s
      ## scrape timeout
      # timeout: 10s
      ## authModule to use for this target
      # authModule: auth_pg
      ## additional metric relabelings
      # metricRelabelings: []
      ## additional relabelings
      # relabelings: []

prometheusRule:
  enabled: false
  additionalLabels: {}
  namespace: ""
  rules: []
    ## These are just examples rules, please adapt them to your needs.
    ## Make sure to constraint the rules to the current prometheus-postgres-exporter service.
    # - alert: HugeReplicationLag
    #   expr: pg_replication_lag{service="{{ template "prometheus-postgres-exporter.fullname" . }}"} / 3600 > 1
    #   for: 1m
    #   labels:
    #     severity: critical
    #   annotations:
    #     description: replication for {{ template "prometheus-postgres-exporter.fullname" . }} PostgreSQL is lagging by {{ "{{ $value }}" }} hour(s).
    #     summary: PostgreSQL replication is lagging by {{ "{{ $value }}" }} hour(s).

priorityClassName: ""

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #    memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

rbac:
  # Specifies whether RBAC resources should be created
  create: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:
  # Add annotations to the ServiceAccount, useful for EKS IAM Roles for Service Accounts or Google Workload Identity.
  annotations: {}

# Add a default ingress to allow namespace access to service.targetPort
# Helpful if other NetworkPolicies are configured in the namespace
networkPolicy:
  # Specifies whether a NetworkPolicy should be created
  enabled: false
  # Set labels for the NetworkPolicy
  labels: {}

# The securityContext of the pod.
# See https://kubernetes.io/docs/concepts/policy/security-context/ for more.
podSecurityContext:
  runAsGroup: 1001
  runAsUser: 1001
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# The securityContext of the container.
# See https://kubernetes.io/docs/concepts/policy/security-context/ for more.
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  privileged: false
  readOnlyRootFilesystem: true

hostAliases: []
  # Set Host Aliases as per https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  # - ip: "127.0.0.1"
  #   hostnames:
  #   - "foo.local"
  #   - "bar.local"

config:
  ## The datasource properties on config are passed through helm tpl function.
  ## ref: https://helm.sh/docs/developing_charts/#using-the-tpl-function
  datasource:
    # Specify one of both datasource or datasourceSecret
    host: ''
    user: postgres
    userSecret: {}
    # Secret name
    #  name:
    # User key inside secret
    #  key:
    # Only one of password, passwordFile, passwordSecret and pgpassfile can be specified
    password:
    # Specify passwordFile if DB password is stored in a file.
    # For example, to use with vault-injector from Hashicorp
    passwordFile: ''
    # Specify passwordSecret if DB password is stored in secret.
    passwordSecret: {}
    # Secret name
    #  name:
    # Password key inside secret
    #  key:
    pgpassfile: ''
    # If pgpassfile is set, it is used to initialize the PGPASSFILE environment variable.
    # See https://www.postgresql.org/docs/14/libpq-pgpass.html for more info.
    port: "5432"
    database: ''
    sslmode: disable
    extraParams: ''
  datasourceSecret: {}
    # Specifies if datasource should be sourced from secret value in format:
    # postgresql://login:password@hostname:port/dbname?sslmode=disable
    # Multiple Postgres databases can be configured by comma separated postgres connection strings
    # Secret name
    #  name:
    # Connection string key inside secret
    #  key:
  disableCollectorDatabase: false
  disableCollectorBgwriter: false
  disableCollectorReplicationSlot: false
  disableDefaultMetrics: false
  disableSettingsMetrics: false

  # possible values debug, info, warn, error, fatal
  logLevel: ""
  # possible values logfmt, json
  logFormat: ""
  ## Extra arguments for the exporter
  extraArgs: []

  ## postgresExporter defines auth modules to store in a configmap
  ## to be mounted as postgres_exporter.yml file
  ## https://github.com/prometheus-community/postgres_exporter#configuration-file
  postgresExporter: ""
    # auth_modules:
    #   first:
    #     type: userpass
    #     userpass:
    #       username: first
    #       password: firstpass
    #     options:
    #       sslmode: disable

  ## Configuration file stored in a secret can be used with postgresExporterSecret.
  ## Key postgres_exporter.yml is used by default.
  postgresExporterConfigSecret: {}
    # name: pg-config-secret
    # key: postgres_exporter.yml

nodeSelector: {}

tolerations: []

affinity: {}

annotations: {}

podLabels: {}

# Configurable health checks
livenessProbe:
  initialDelaySeconds: 0
  timeoutSeconds: 3

readinessProbe:
  initialDelaySeconds: 0
  timeoutSeconds: 1

# Labels and annotations to attach to the deployment resource
deployment:
  labels: {}
  annotations: {}

# ExtraEnvs
extraEnvs: []
  # - name: EXTRA_ENV
  #   value: value
  # - name: POD_NAMESPACE
  #   valueFrom:
  #     fieldRef:
  #       fieldPath: metadata.namespace

# Init containers, e. g. for secrets creation before the exporter
initContainers: []
  # - name:
  #   image:
  #   volumeMounts:
  #     - name: creds
  #       mountPath: /creds

# Additional sidecar containers, e. g. for a database proxy, such as Google's cloudsql-proxy
extraContainers: []

# Additional volumes, e. g. for secrets used in an extraContainer
extraVolumes: []
# Uncomment for mounting custom ca-certificates
#  - name: ssl-certs
#    secret:
#      defaultMode: 420
#      items:
#      - key: ca-certificates.crt
#        path: ca-certificates.crt
#      secretName: ssl-certs

# Additional volume mounts
extraVolumeMounts: []
# Uncomment for mounting custom ca-certificates file into container
#  - name: ssl-certs
#    mountPath: /etc/ssl/certs/ca-certificates.crt
#    subPath: ca-certificates.crt

podDisruptionBudget:
  enabled: false
  maxUnavailable: 1
